# -*- coding: utf-8 -*-
"""MATH899_Research.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lST6Qf9qAsY657DaoxrLtSrG9WvEJJ-7
"""

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import glob

from IPython.display import display_html
from numpy.ma.core import conjugate

pd.__version__

"""# Pre-processing"""

tol = 1.0e-10

# Utility
def is_equal(a, b):
  if (abs(a.real - b.real) < tol and abs(a.imag - b.imag) < tol):
      return True
  else: return False

# test
a = 1.0e-10 + 2j; b = 1.5e-10 + 2j
assert is_equal(a, b)
a = 1.0e-10 + 2j; b = 2.5e-10 + 2j
assert not is_equal(a, b)

a = 1 + 1.0e-10j; b = 1 + 1.5e-10j
assert is_equal(a, b)
a = 1 + 1.0e-10j; b = 1 + 2.5e-10j
assert not is_equal(a, b)


def highlight_cells(c):
  color = ''
  if (not is_equal(c.imag, 0.0)):
    color = 'orange'
  if (
      is_equal(c.imag, 0j) and
      not is_equal(c.real, 0)
  ):
    color = 'lightgreen' 
  return 'background-color: {}'.format(color)


def view_solutions(sample):
  return pd.DataFrame(sample['All_sols'], columns=sample['variables']).style.applymap(highlight_cells)

def display_dict(d):
  for (k, v) in d.items():
    print(k, " : ", v)





# text parsing
def parse(x):
  if len(x) > 0:
    return eval(x[3:])
  else:
    return None

def parse1(x):
  if len(x) > 0:
    l = parse(x)
    return l[1]
  else:
    return None

def parse_complex(s):
  M = []
  def func(s):
    t = s.replace('im', 'j')
    return eval(t)

  if len(s) > 0:
    s = s[19:]
    s = s[:-1]
    l = s.split("], ")
    l[-1] = l[-1][:-1]
    for x in l:
      v = []
      xx = x[1:].split(",")
      for yy in xx:
        c = func(yy)
        r = c.real
        im = c.imag
        if abs(r) < tol:
          r = 0.0
        if abs(im) < tol:
          im = 0.0
        v.append(complex(r, im))
      M.append(v)
    return M
  else:
    return None

def parse_vars(s):
  if len(s) > 0:
    s = s[9:]
    s = s[:-1]
    return s.split(",")
  else:
    return None

# summary statistics

def mean_(s):
  return int(np.ceil(np.mean(s)))


def get_max(x):
  if len(x) > 0:
    return round(max(x), ndigits=4)
  else:
    return None

def get_min(x):
  if len(x) > 0:
    return round(min(x), ndigits=4)
  else:
    return None

def get_sum(x):
  if len(x) > 0:
    return sum([y == 0 for y in x])
  else:
    return None

def get_N_0(x):
  # no. of solutions with index 0
  return sum([y == 0 for y in x])

def get_N_1(x):
  # no. of solutions with index 1
  if len(x) > 0:
    return sum([y == 1 for y in x])
  else:
    return None

def get_N_2(x):
  # no. of solutions with index 2
  if len(x) > 0:
    return sum([y == 2 for y in x])
  else:
    return None

def get_N_3(x):
  # no. of solutions with index 3
  if len(x) > 0:
    return sum([y == 3 for y in x])
  else:
    return None

def get_N_4(x):
  # no. of solutions with index 4
  if len(x) > 0:
    return sum([y == 4 for y in x])
  else:
    return None

def get_N_C_star(row):
  count = 0
  for v in row:
    zero_count = sum([1 if is_equal(x, 0) else 0 for x in v])
    if zero_count == 0:
      count += 1
  return count

#test
r = [[1, 0], [0, 1]]
assert get_N_C_star(r) == 0
r = [[1, 1],[1, 0]]
assert get_N_C_star(r) == 1

from collections import OrderedDict
class Condition():
  cols = ['convolution','reg','di','H','m','dx','dy','width','stride','Lambda','BKK','N_C','N_R']
  
  def __init__(self):
    od = OrderedDict()
    od['convolution'] = False
    od['reg'] = True
    od['di'] = 2
    od['H'] = 1
    od['m'] = 1
    od['dx'] = 2
    od['dy'] = 2
    od['width'] = 1
    od['stride'] = 1
    od['Lambda'] = 1
    self.dict = od

  def apply(self, data):
    s = ""
    for k, v in self.dict.items():
      s = s + "& (data.{} == {}) ".format(k, v)
    s = "(" + s[1:] + ")"
    
    return data[eval(s)][self.cols]

  def reset(self):
    self.__init__()

# Validate data
file_list = glob.glob("sample_data/math899/*.csv")
if file_list == []:
  raise Exception("No files found! Check directory name...")
else:
  print(len(file_list), " files found...")

for file in file_list:
  # print(file)
  temp = pd.read_csv(file, delimiter="&")
  dx = int(file[36:37])
  dy = int(file[39:40])
  instance_Id = file[-23:-4]
  vc = temp[['dx', 'dy']].value_counts()
  try:
    assert dx == vc.index[0][0]
    assert dy == vc.index[0][1]
    assert(vc.values[0]==100)
  except Exception as e:
    print("Error when reading file: ", file)
    print(e)
    print("value counts returned: \n", vc)

# read validated data
data = pd.DataFrame()
for file in file_list:
  data_temp = pd.read_csv(file, delimiter="&")
  data = pd.concat([data, data_temp])

data.columns

# clean and format list-like entries
data = data.assign(
    variables = data.variables.apply(parse_vars),
    All_sols = data.All_sols.apply(parse_complex),
    Real_sols = data.Real_sols.apply(parse),
    L_values = data.L_values.apply(parse),
    Idx_vals = data.Idx_vals.apply(parse),
    Lambda = data.reg_dist_params.apply(parse1) # note parse1
)

# generate first order summary columns
data = data.assign(
    L_min = data.L_values.apply(get_min),
    L_max = data.L_values.apply(get_max),
    Idx_max = data.Idx_vals.apply(get_max),
    N_C_star = data.All_sols.apply(get_N_C_star),
    N_0 = data.Idx_vals.apply(get_N_0),
    N_1 = data.Idx_vals.apply(get_N_1),
    N_2 = data.Idx_vals.apply(get_N_2),
    N_3 = data.Idx_vals.apply(get_N_3),
    N_4 = data.Idx_vals.apply(get_N_4)
)

# generate second order summary columns
data = data.assign(N1_N = data['N_1']/data['N_R'])

# data.columns

data.shape

"""# Analysis"""

def get_subspaces(sample, real_only=False):
  """Find distinct subspaces in the solution set."""
  d = dict()
  if real_only:
    col = 'Real_sols'
  else:
    col = 'All_sols'
  for v in sample[col]:
    k = str([1 if not is_equal(x, 0) else 0 for x in v])
    if k in d.keys():
      d[k] += 1
    else:
      d[k] = 1

  # i = 65
  # for k in d.keys():
  #   print(chr(i), k)
  #   i += 1
  
  return d

def orthogonal(u1, u2):
  """Check if a given pair of subspaces are orthogonal."""
  if np.dot(u1, u2) == 0:
    return True
  else:
    return False

# test
u1 = [1, 0, 1, 0]
u2 = [0, 1, 0, 1]
assert orthogonal(u1, u2)

u1 = [1, 0, 1, 0]
u2 = [1, 1, 0, 1]
assert not orthogonal(u1, u2)


def dimension(u1):
  """Compute the dimension of a subspace."""
  return sum(u1)
# test
assert dimension([1, 1, 0, 1]) == 3


def contains(sup, sub):
  """True if sup contains sub. False otherwise."""
  if sum(sup) < sum(sub):
    return False

  if len(sup) != len(sub):
    raise Exception("cannot compare lists of different lengths!")

  for i in range(len(sub)):
    if sub[i] == 1:
      if sup[i] != 1:
        return False

  return True

# test
sup = [1, 0, 0, 1]
sub = [1, 0, 0, 0]
assert contains(sup, sub)

sup = [1, 0, 0, 1]
sub = [1, 0, 1, 0]
assert not contains(sup, sub)

sup = [1, 0, 0]
sub = [1, 1, 0]
assert not contains(sup, sub)



def get_orth_pairs(d):
  l = list(d.keys())
  orth_pairs = []
  for i in range(len(l)):
    for j in range(i+1, len(l)):
      u1 = np.array(eval(l[i]))
      u2 = np.array(eval(l[j]))
      if np.dot(u1, u2) == 0:
        orth_pairs.append((u1, u2))
  return orth_pairs

def get_weight_matrices(sol, di, H, dx, dy):
  v = np.array(sol)
  n = di * dx + (H -1) * di * di + dy * di

  if len(v) != n:
    raise Exception(
        "Length of solution vector {} does not match the architecture\n di={}; H={}; dx={}; dy={}.".format(n, di, H, dx, dy))
  pos = 0
  W_list = []
  for i in range(H+1):
    if i == 0:
      W = v[pos : di*dx].reshape(di, dx)
      pos = pos + di*dx
      W_list.append(W)
    elif i == H:
      W = v[pos: ].reshape(dy, di)
      pos = pos + di*dx
      W_list.append(W)
    else:
      W = v[pos: pos + di*di].reshape(di, di)
      pos = pos + di*di
      W_list.append(W)
  return W_list

#test
v = [1, 2, 3, 4]; di=2; H=1; dx=1; dy=1
W_list = get_weight_matrices(v, di, H, dx, dy)
assert W_list[0].shape == (2, 1)
assert W_list[0][0] == [1]
assert W_list[0][1] == [2]

assert W_list[1].shape == (1, 2)
assert W_list[1][0][0] == 3
assert W_list[1][0][1] == 4

v = [1, 2, 3, 4, 5, 6, 7, 8]; di=2; H=2; dx=1; dy=1
W_list = get_weight_matrices(v, di, H, dx, dy)
assert W_list[0].shape == (2, 1)
assert W_list[1].shape == (2, 2)
assert W_list[2].shape == (1, 2)

def prettify(W, caption=""):
  styler = W.style.set_table_styles(
    [{'selector': 'thead', 'props': [('display', 'none')]}],
    axis=0)
  styler.hide_index()
  styler.set_table_attributes("style='display:inline'")
  styler.set_caption(caption)
  return styler

def format_weight_matrices(W_list):
  W_temp = W_list.copy()
  W_temp.reverse()
  s = ''
  i = len(W_temp)
  for W in W_temp:
    cap = "W"+str(i)
    styler = prettify(pd.DataFrame(W), caption=cap)
    s += styler._repr_html_()
    i -= 1
  return s

# # Don't reverse the weight matrices when displaying
# def format_weight_matrices(W_list):
#   W_temp = W_list.copy()
#   W_temp.reverse()
#   s = ''
#   i = 1
#   for W in W_temp:
#     cap = "W"+str(i)
#     styler = prettify(pd.DataFrame(W), caption=cap)
#     s += styler._repr_html_()
#     i += 1
#   return s

def analyze(sample):
  subs = get_subspaces(sample, real_only=False)

  for k, v in subs.items():
    W_list = get_weight_matrices(eval(k), sample.di, sample.H, sample.dx, sample.dy)
    stl2 = format_weight_matrices(W_list)

    # print stuff
    display_html(stl2, raw=True)
    # print("subspace dim: {}".format(dimension(eval(k))))
    print("solution count: {}\n\n".format(v))



case = data[(data.di==2) &
              (data.H==2) &
              (data.m==2) &
              (data.dx==1) &
              (data.dy==2)]

"""### Analyzing the case"""

case.columns

case.N_R.max()

case.N_R.hist()

import operator as op
from functools import reduce

def ncr(n, r):
    r = min(r, n-r)
    numer = reduce(op.mul, range(n, n-r, -1), 1)
    denom = reduce(op.mul, range(1, r+1), 1)
    return numer // denom  # or / in Python 2



def get_B_C_start(d, p):
  return (4*p)**d

def get_B_C(d,p):
  sum = 0
  for r in range(1, d+1):
    sum += ncr(d,r)*get_B_C_start(r, p)
  return sum

##### PRINT CASE #####
rows = []
for di in range(1, 4):
  for H in range(1, 3):
    for m in range(1, 3):
      for dy in range(1, 5):
        for dx in range(1, 5):
          case = data[(data.di==di) &
                (data.H==H) &
                (data.m==m) &
                (data.dx==dx) &
                (data.dy==dy)]
          if len(case) > 0:
            N_R_max = case.N_R.max()
            if H ==1 & m ==1:
              B_C_start = get_B_C_start(di, dy)
              B_C = get_B_C(di, dy) + 1
            else:
              B_C_start = -1
              B_C = -1
            
            case = case[['di', 'H', 'm', 'dx', 'dy', 'n','CBB', 'BKK', 'N_C', 'N_C_star']]
            # print(" ############ di={}, H={}, m={}, dx={}, dy={} ############\n".format(di, H, m, dx, dy))

            # take the max of each column to avoid discrepancies
            r = case.max()

            # add entries
            r = r.to_dict()
            r["B_C"] = B_C
            r["B_C_start"] = B_C_start 
            r["N_R_max"] = N_R_max

            # append
            row = pd.Series(r)
            rows.append(row)
          else:
            pass
          # break
        # break
      # break
    # break
  # break

df_table = pd.DataFrame(rows).sort_values(by=['H', 'di', 'dx', 'dy', 'm'])

df_table[[
          'H',
          'm',
          'di',
          'dx',
          'dy',
          'n',
          'CBB',
          'BKK',
          'B_C',
          'B_C_start',
          'N_C',
          'N_C_star',
          'N_R_max']]



"""### Analyzing the sample"""

sample = data[(data.di==2) &
              (data.H==2) &
              (data.m==2) &
              (data.dx==1) &
              (data.dy==2)].loc[62]

# view_solutions(sample)

analyze(sample)



# ~ PRINT COORDINATE DECOMPOSITIONS ~ #
for di in range(2, 3):
  for H in range(2, 3):
    for m in range(2, 3):
      for dy in range(1, 5):
        for dx in range(1, 5):
          try:
            sample = data[(data.di==di) &
                          (data.H==H) &
                          (data.m==m) &
                          (data.dx==dx) &
                          (data.dy==dy)].loc[67]
            print(" ####################### di={}, H={}, m={}, dx={}, dy={} #####################\n".format(di, H, m, dx, dy))
            analyze(sample)
          except:
            print("Not available: di={}, H={}, m={}, dx={}, dy={}. Ignoring...\n".format(di, H, m, dx, dy))
            pass

